//! Play Match Scene - 3D Combat Arena
//!
//! This module handles the active match simulation where combatants battle each other.
//! Inspired by World of Warcraft's combat mechanics, it features:
//!
//! ## Combat System
//! - **Target Acquisition**: Combatants automatically find the nearest alive enemy
//! - **Movement**: Combatants move towards targets if out of range
//! - **Range Mechanics**: Melee attacks require being in melee range (2.5 units)
//! - **Auto-Attacks**: Each combatant attacks when in range, based on attack speed
//! - **Damage & Stats**: Tracks damage dealt/taken for each combatant
//! - **Win Conditions**: Match ends when all combatants of one team are eliminated
//!
//! ## Visual Representation
//! - 3D capsule meshes represent combatants, colored by class
//! - Health bars rendered above each combatant's head using 2D overlay
//! - Combatants rotate to face their targets
//! - Simple arena floor (60x60 plane)
//! - Isometric camera view
//!
//! ## Flow
//! 1. `setup_play_match`: Spawns arena, camera, lights, and combatants from `MatchConfig`
//! 2. Systems run each frame:
//!    - `update_play_match`: Handle ESC key to exit
//!    - `acquire_targets`: Find nearest enemy for each combatant
//!    - `move_to_target`: Move combatants towards targets if out of range
//!    - `combat_auto_attack`: Process attacks when in range, based on attack speed
//!    - `check_match_end`: Detect when match is over, transition to Results
//!    - `render_health_bars`: Draw 2D health bars over 3D combatants
//! 3. `cleanup_play_match`: Despawn all entities when exiting

// Submodules
pub mod abilities;
pub mod components;
pub mod camera;
pub mod projectiles;
pub mod rendering;
pub mod auras;
pub mod match_flow;
pub mod combat_ai;

// Re-exports
pub use abilities::*;
pub use components::*;
pub use camera::*;
pub use projectiles::*;
pub use rendering::*;
pub use auras::*;
pub use match_flow::*;
pub use combat_ai::*;

use bevy::prelude::*;
use bevy_egui::{egui, EguiContexts};
use super::match_config::{self, MatchConfig};
use super::GameState;
use crate::combat::log::{CombatLog, CombatLogEventType, PositionData, MatchMetadata, CombatantMetadata};

// ============================================================================
// Constants
// ============================================================================

/// Melee attack range in units. Combatants must be within this distance to auto-attack.
/// Similar to WoW's melee range of ~5 yards.
const MELEE_RANGE: f32 = 2.5;

/// Ranged wand attack range for caster classes (Mage, Priest).
/// Similar to WoW's wand range of ~30 yards.
const WAND_RANGE: f32 = 30.0;

/// Distance threshold for stopping movement (slightly less than melee range to avoid jitter)
const STOP_DISTANCE: f32 = 2.0;

/// Arena size (80x80 plane centered at origin, includes starting areas)
const ARENA_HALF_SIZE: f32 = 40.0;

/// Floating combat text horizontal spread (multiplied by -0.5 to +0.5 range)
/// Adjust this to control how far left/right numbers can appear from their spawn point
const FCT_HORIZONTAL_SPREAD: f32 = 1.2; // Default: 0.8 (range: -0.4 to +0.4)

/// Floating combat text vertical spread (0.0 to this value)
/// Adjust this to control the vertical stagger of numbers
const FCT_VERTICAL_SPREAD: f32 = 0.8; // Default: 0.5 (range: 0.0 to 0.5)


// ============================================================================
// Helper Functions
// ============================================================================

/// Helper function to get next floating combat text offset and update pattern state
/// Returns (x_offset, y_offset) based on deterministic alternating pattern
fn get_next_fct_offset(state: &mut FloatingTextState) -> (f32, f32) {
    let (x_offset, y_offset) = match state.next_pattern_index {
        0 => (0.0, 0.0),  // Center
        1 => (FCT_HORIZONTAL_SPREAD * 0.4, FCT_VERTICAL_SPREAD * 0.3),  // Right side, slight up
        2 => (FCT_HORIZONTAL_SPREAD * -0.4, FCT_VERTICAL_SPREAD * 0.6), // Left side, more up
        _ => (0.0, 0.0),  // Fallback to center
    };
    
    // Cycle to next pattern: 0 -> 1 -> 2 -> 0
    state.next_pattern_index = (state.next_pattern_index + 1) % 3;
    
    (x_offset, y_offset)
}

// ============================================================================
// Setup & Cleanup Systems
// ============================================================================

/// Setup system: Spawns the 3D arena, camera, lighting, and combatants.
/// 
/// This runs once when entering the PlayMatch state.
/// Reads the `MatchConfig` resource to determine team compositions.
pub fn setup_play_match(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut combat_log: ResMut<CombatLog>,
    config: Res<MatchConfig>,
) {
    info!("Setting up Play Match scene with config: {:?}", *config);
    
    // Clear combat log for new match
    combat_log.clear();
    combat_log.log(CombatLogEventType::MatchEvent, "Match started!".to_string());

    // Spawn 3D camera with isometric-ish view
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(0.0, 40.0, 50.0).looking_at(Vec3::ZERO, Vec3::Y),
        ArenaCamera,
        PlayMatchEntity,
    ));

    // Add directional light (sun-like)
    commands.spawn((
        DirectionalLight {
            illuminance: 20000.0,
            shadows_enabled: false,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0).looking_at(Vec3::ZERO, Vec3::Y),
        PlayMatchEntity,
    ));

    // Add ambient light for overall scene brightness
    commands.insert_resource(AmbientLight {
        color: Color::srgb(0.3, 0.3, 0.4),
        brightness: 300.0,
    });
    
    // Initialize simulation speed control
    commands.insert_resource(SimulationSpeed { multiplier: 1.0 });
    
    // Initialize camera controller
    commands.insert_resource(CameraController::default());
    
    // Initialize match countdown (10 seconds before gates open)
    commands.insert_resource(MatchCountdown::default());

    // Spawn arena floor - 80x80 unit plane (includes starting areas)
    let floor_size = 80.0;
    commands.spawn((
        Mesh3d(meshes.add(Plane3d::default().mesh().size(floor_size, floor_size))),
        MeshMaterial3d(materials.add(StandardMaterial {
            base_color: Color::srgb(0.2, 0.25, 0.3),
            perceptual_roughness: 0.9,
            ..default()
        })),
        PlayMatchEntity,
    ));

    // Count class occurrences per team to apply darkening to duplicates
    use std::collections::HashMap;
    let mut team1_class_counts: HashMap<match_config::CharacterClass, usize> = HashMap::new();
    let mut team2_class_counts: HashMap<match_config::CharacterClass, usize> = HashMap::new();

    // Spawn Team 1 combatants (left side of arena, in starting pen)
    // Teams start further back (-35/+35) and will move forward when gates open
    let team1_spawn_x = -35.0;
    for (i, character_opt) in config.team1.iter().enumerate() {
        if let Some(character) = character_opt {
            let count = *team1_class_counts.get(character).unwrap_or(&0);
            *team1_class_counts.entry(*character).or_insert(0) += 1;
            
            spawn_combatant(
                &mut commands,
                &mut meshes,
                &mut materials,
                1,
                *character,
                Vec3::new(team1_spawn_x, 1.0, (i as f32 - 1.0) * 3.0),
                count,
            );
        }
    }

    // Spawn Team 2 combatants (right side of arena, in starting pen)
    let team2_spawn_x = 35.0;
    for (i, character_opt) in config.team2.iter().enumerate() {
        if let Some(character) = character_opt {
            let count = *team2_class_counts.get(character).unwrap_or(&0);
            *team2_class_counts.entry(*character).or_insert(0) += 1;
            
            spawn_combatant(
                &mut commands,
                &mut meshes,
                &mut materials,
                2,
                *character,
                Vec3::new(team2_spawn_x, 1.0, (i as f32 - 1.0) * 3.0),
                count,
            );
        }
    }
}

/// Helper function to spawn a single combatant entity.
/// 
/// Creates a capsule mesh colored by class, with darker shades for duplicates.
/// The `duplicate_index` parameter determines how much to darken (0 = base color, 1+ = darkened).
fn spawn_combatant(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
    team: u8,
    class: match_config::CharacterClass,
    position: Vec3,
    duplicate_index: usize,
) {
    // Get vibrant class colors for 3D visibility
    let base_color = match class {
        match_config::CharacterClass::Warrior => Color::srgb(0.9, 0.6, 0.3), // Orange/brown
        match_config::CharacterClass::Mage => Color::srgb(0.3, 0.6, 1.0),    // Bright blue
        match_config::CharacterClass::Rogue => Color::srgb(1.0, 0.9, 0.2),   // Bright yellow
        match_config::CharacterClass::Priest => Color::srgb(0.95, 0.95, 0.95), // White
    };
    
    // Apply darkening for duplicate classes (0.65 multiplier per duplicate)
    let darken_factor = 0.65f32.powi(duplicate_index as i32);
    let combatant_color = Color::srgb(
        base_color.to_srgba().red * darken_factor,
        base_color.to_srgba().green * darken_factor,
        base_color.to_srgba().blue * darken_factor,
    );

    // Create combatant mesh (capsule represents the body)
    let mesh = meshes.add(Capsule3d::new(0.5, 1.5));
    let material = materials.add(StandardMaterial {
        base_color: combatant_color,
        perceptual_roughness: 0.5, // More reflective for better color visibility
        metallic: 0.2, // Slight metallic sheen for color pop
        // Enable alpha mode for stealth transparency
        alpha_mode: bevy::prelude::AlphaMode::Blend,
        ..default()
    });

    commands.spawn((
        Mesh3d(mesh),
        MeshMaterial3d(material),
        Transform::from_translation(position),
        Combatant::new(team, class),
        FloatingTextState {
            next_pattern_index: 0,
        },
        PlayMatchEntity,
    ));
}

/// Handle camera input for mode switching, zoom, rotation, and drag

/// Cleanup system: Despawns all Play Match entities when exiting the state.
pub fn cleanup_play_match(
    mut commands: Commands,
    query: Query<Entity, With<PlayMatchEntity>>,
) {
    for entity in query.iter() {
        commands.entity(entity).despawn_recursive();
    }
    
    // Remove resources
    commands.remove_resource::<AmbientLight>();
    commands.remove_resource::<SimulationSpeed>();
    commands.remove_resource::<MatchCountdown>();
    // Remove optional resources (may not exist if match didn't finish)
    commands.remove_resource::<VictoryCelebration>();
}

// ============================================================================
// Update & Input Systems
// ============================================================================

/// Countdown system: Manage pre-combat countdown and gate opening.
/// 
/// During countdown (10 seconds):
/// - Mana is restored to 100% every second (encourages pre-buffing)
/// - Combatants can cast buffs but cannot move or attack
/// - Countdown timer ticks down
/// 
/// When countdown reaches 0:
/// - Gates open (sets gates_opened flag)
/// - Combat begins normally

/// Render time control UI panel in the top-right corner.
/// 
/// Shows current speed and clickable buttons for speed control.
/// Handle player input during the match.
/// Currently only handles ESC key to return to main menu.
pub fn update_play_match(
    keybindings: Res<crate::keybindings::Keybindings>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    use crate::keybindings::GameAction;
    
    if keybindings.action_just_pressed(GameAction::Back, &keyboard) {
        next_state.set(GameState::MainMenu);
    }
}

// ============================================================================
// Combat Systems
// ============================================================================

/// Target acquisition system: Each combatant finds the nearest alive enemy.
/// 
/// This runs every frame to update targets when:
/// - A combatant has no target
    }
}

/// Movement system: Move combatants towards their targets if out of range.
/// 
/// Combatants will:
/// - Move towards their target if they have one and are out of melee range
/// - Stop moving when within attack range
/// - Rotate to face their target
/// - **WoW Mechanic**: Cannot move while casting (checked via `CastingState`)
/// - Movement speed modified by auras (e.g., Frostbolt's slow)
/// 
/// This creates the WoW-like behavior where melee combatants chase each other around the arena.

/// Find the best direction to move while kiting that maximizes distance from enemy
/// while staying within arena bounds.
/// 
/// Strategy:
/// 1. Try the direct "away from enemy" direction first
/// 2. If that would hit a boundary, test multiple candidate directions
/// 3. Pick the direction that maximizes distance from enemy while staying in bounds
fn find_best_kiting_direction(
    current_pos: Vec3,
    enemy_pos: Vec3,
    move_distance: f32,
) -> Vec3 {
    // Calculate ideal direction (directly away from enemy)
    let ideal_direction = Vec3::new(
        current_pos.x - enemy_pos.x,
        0.0,
        current_pos.z - enemy_pos.z,
    ).normalize_or_zero();
    
    if ideal_direction == Vec3::ZERO {
        return Vec3::ZERO; // Already on top of enemy, can't kite
    }
    
    // Check if ideal direction keeps us in bounds
    let ideal_next_pos = current_pos + ideal_direction * move_distance;
    let ideal_in_bounds = 
        ideal_next_pos.x >= -ARENA_HALF_SIZE && ideal_next_pos.x <= ARENA_HALF_SIZE &&
        ideal_next_pos.z >= -ARENA_HALF_SIZE && ideal_next_pos.z <= ARENA_HALF_SIZE;
    
    if ideal_in_bounds {
        return ideal_direction; // Ideal direction works, use it!
    }
    
    // Ideal direction would hit boundary - find best alternative
    // Test 16 directions around a circle and pick the one that:
    // 1. Stays in bounds
    // 2. Maximizes distance from enemy
    let mut best_direction = Vec3::ZERO;
    let mut best_score = f32::MIN;
    
    for i in 0..16 {
        let angle = (i as f32) * std::f32::consts::TAU / 16.0;
        let candidate_direction = Vec3::new(
            angle.cos(),
            0.0,
            angle.sin(),
        );
        
        // Calculate where we'd end up with this direction
        let candidate_next_pos = current_pos + candidate_direction * move_distance;
        
        // Check if this keeps us in bounds
        let in_bounds = 
            candidate_next_pos.x >= -ARENA_HALF_SIZE && candidate_next_pos.x <= ARENA_HALF_SIZE &&
            candidate_next_pos.z >= -ARENA_HALF_SIZE && candidate_next_pos.z <= ARENA_HALF_SIZE;
        
        if !in_bounds {
            continue; // Skip directions that go out of bounds
        }
        
        // Score this direction based on:
        // 1. Distance from enemy (higher = better)
        // 2. Alignment with ideal direction (bonus for moving away, not sideways)
        let distance_from_enemy = candidate_next_pos.distance(enemy_pos);
        let alignment_with_ideal = candidate_direction.dot(ideal_direction).max(0.0);
        let score = distance_from_enemy * 2.0 + alignment_with_ideal * 5.0;
        
        if score > best_score {
            best_score = score;
            best_direction = candidate_direction;
        }
    }
    
    best_direction
}

pub fn move_to_target(
    countdown: Res<MatchCountdown>,
    time: Res<Time>,
    mut commands: Commands,
    mut combatants: Query<(Entity, &mut Transform, &Combatant, Option<&ActiveAuras>, Option<&CastingState>, Option<&ChargingState>)>,
) {
    // Don't allow movement until gates open
    if !countdown.gates_opened {
        return;
    }
    
    let dt = time.delta_secs();
    
    // Build a snapshot of all combatant positions and team info for lookups
    let positions: std::collections::HashMap<Entity, (Vec3, u8)> = combatants
        .iter()
        .map(|(entity, transform, combatant, _, _, _)| (entity, (transform.translation, combatant.team)))
        .collect();
    
    // Move each combatant towards their target if needed
    for (entity, mut transform, combatant, auras, casting_state, charging_state) in combatants.iter_mut() {
        if !combatant.is_alive() {
            continue;
        }
        
        // Cannot move while casting (WoW mechanic)
        if casting_state.is_some() {
            continue;
        }
        
        // Check if rooted or stunned - if so, cannot move
        let is_cc_locked = if let Some(auras) = auras {
            auras.auras.iter().any(|a| matches!(a.effect_type, AuraType::Root | AuraType::Stun))
        } else {
            false
        };
        
        if is_cc_locked {
            continue;
        }
        
        let my_pos = transform.translation;
        
        // CHARGING BEHAVIOR: If charging, move at high speed toward target ignoring slows
        if let Some(charge_state) = charging_state {
            let Some(&(target_pos, _)) = positions.get(&charge_state.target) else {
                // Target doesn't exist, cancel charge
                commands.entity(entity).remove::<ChargingState>();
                continue;
            };
            
            let distance = my_pos.distance(target_pos);
            
            // If we've reached melee range, end the charge
            if distance <= MELEE_RANGE {
                commands.entity(entity).remove::<ChargingState>();
                
                info!(
                    "Team {} {} completes charge!",
                    combatant.team,
                    combatant.class.name()
                );
                
                continue; // Will use normal movement/combat next frame
            }
            
            // Calculate direction to target
            let direction = Vec3::new(
                target_pos.x - my_pos.x,
                0.0,
                target_pos.z - my_pos.z,
            ).normalize_or_zero();
            
            if direction != Vec3::ZERO {
                // Charge speed: 4x normal movement speed, ignores slows
                const CHARGE_SPEED_MULTIPLIER: f32 = 4.0;
                let charge_speed = combatant.base_movement_speed * CHARGE_SPEED_MULTIPLIER;
                let move_distance = charge_speed * dt;
                
                // Move towards target
                transform.translation += direction * move_distance;
                
                // Clamp position to arena bounds
                transform.translation.x = transform.translation.x.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                transform.translation.z = transform.translation.z.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                
                // Rotate to face target
                let target_rotation = Quat::from_rotation_y(direction.x.atan2(direction.z));
                transform.rotation = target_rotation;
            }
            
            continue; // Skip normal movement logic while charging
        }
        
        // KITING BEHAVIOR: If kiting_timer > 0, move away from nearest enemy
        // Uses intelligent pathfinding that considers arena boundaries
        if combatant.kiting_timer > 0.0 {
            // Find nearest enemy
            let mut nearest_enemy_pos: Option<Vec3> = None;
            let mut nearest_distance = f32::MAX;
            
            for (other_entity, &(other_pos, other_team)) in positions.iter() {
                if *other_entity != entity && other_team != combatant.team {
                    let distance = my_pos.distance(other_pos);
                    if distance < nearest_distance {
                        nearest_distance = distance;
                        nearest_enemy_pos = Some(other_pos);
                    }
                }
            }
            
            // Intelligent kiting: maximize distance from nearest enemy
            if let Some(enemy_pos) = nearest_enemy_pos {
                // Calculate effective movement speed (base * aura modifiers)
                let mut movement_speed = combatant.base_movement_speed;
                if let Some(auras) = auras {
                    for aura in &auras.auras {
                        if aura.effect_type == AuraType::MovementSpeedSlow {
                            movement_speed *= aura.magnitude;
                        }
                    }
                }
                
                let move_distance = movement_speed * dt;
                
                // Find the best direction to move that maximizes distance from enemy
                // while staying within arena bounds
                let best_direction = find_best_kiting_direction(
                    my_pos,
                    enemy_pos,
                    move_distance,
                );
                
                if best_direction != Vec3::ZERO {
                    // Move in the best direction
                    transform.translation += best_direction * move_distance;
                    
                    // Ensure we stay in bounds (in case of floating point errors)
                    transform.translation.x = transform.translation.x.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                    transform.translation.z = transform.translation.z.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                    
                    // Rotate to face direction of travel
                    let target_rotation = Quat::from_rotation_y(best_direction.x.atan2(best_direction.z));
                    transform.rotation = target_rotation;
                }
            }
            
            continue; // Skip normal movement logic
        }
        
        // NORMAL MOVEMENT: Get target position
        let Some(target_entity) = combatant.target else {
            // No target available (likely facing all-stealth team)
            // Move to defensive position in center of arena to anticipate stealth openers
            let defensive_pos = Vec3::ZERO; // Center of arena
            let distance_to_defensive = my_pos.distance(defensive_pos);
            
            // Only move if we're far from the defensive position (> 5 units)
            if distance_to_defensive > 5.0 {
                let direction = Vec3::new(
                    defensive_pos.x - my_pos.x,
                    0.0,
                    defensive_pos.z - my_pos.z,
                ).normalize_or_zero();
                
                if direction != Vec3::ZERO {
                    // Calculate effective movement speed
                    let mut movement_speed = combatant.base_movement_speed;
                    if let Some(auras) = auras {
                        for aura in &auras.auras {
                            if aura.effect_type == AuraType::MovementSpeedSlow {
                                movement_speed *= aura.magnitude;
                            }
                        }
                    }
                    
                    // Move towards defensive position
                    let move_distance = movement_speed * dt;
                    transform.translation += direction * move_distance;
                    
                    // Clamp position to arena bounds
                    transform.translation.x = transform.translation.x.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                    transform.translation.z = transform.translation.z.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                    
                    // Rotate to face center
                    let target_rotation = Quat::from_rotation_y(direction.x.atan2(direction.z));
                    transform.rotation = target_rotation;
                }
            }
            
            continue;
        };
        
        let Some(&(target_pos, _)) = positions.get(&target_entity) else {
            continue;
        };
        
        let distance = my_pos.distance(target_pos);
        
        // Determine stop distance based on attack range (melee or wand)
        // Stop slightly before attack range to avoid jitter
        let stop_distance = match combatant.class {
            match_config::CharacterClass::Mage | match_config::CharacterClass::Priest => {
                WAND_RANGE - 1.0 // Stop 1 unit before wand range
            }
            match_config::CharacterClass::Warrior | match_config::CharacterClass::Rogue => {
                STOP_DISTANCE // Use standard melee stop distance
            }
        };
        
        // If out of range, move towards target
        if distance > stop_distance {
            // Calculate direction to target (only in XZ plane, keep Y constant)
            let direction = Vec3::new(
                target_pos.x - my_pos.x,
                0.0, // Don't move vertically
                target_pos.z - my_pos.z,
            ).normalize_or_zero();
            
            if direction != Vec3::ZERO {
                // Calculate effective movement speed (base * aura modifiers)
                let mut movement_speed = combatant.base_movement_speed;
                if let Some(auras) = auras {
                    for aura in &auras.auras {
                        if aura.effect_type == AuraType::MovementSpeedSlow {
                            movement_speed *= aura.magnitude;
                        }
                    }
                }
                
                // Move towards target
                let move_distance = movement_speed * dt;
                transform.translation += direction * move_distance;
                
                // Clamp position to arena bounds
                transform.translation.x = transform.translation.x.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                transform.translation.z = transform.translation.z.clamp(-ARENA_HALF_SIZE, ARENA_HALF_SIZE);
                
                // Rotate to face target
                let target_rotation = Quat::from_rotation_y(direction.x.atan2(direction.z));
                transform.rotation = target_rotation;
            }
        }
    }
}

/// Update visual appearance of stealthed combatants.
/// 
/// Makes stealthed Rogues semi-transparent (40% alpha) with a darker tint
/// to clearly indicate their stealth status. When they break stealth (e.g., by using Ambush),
/// they return to full opacity and original color.
pub fn update_stealth_visuals(
    combatants: Query<(&Combatant, &MeshMaterial3d<StandardMaterial>), Changed<Combatant>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    for (combatant, material_handle) in combatants.iter() {
        if let Some(material) = materials.get_mut(&material_handle.0) {
            let current_color = material.base_color.to_srgba();
            let current_alpha = current_color.alpha;
            
            if combatant.stealthed {
                // Only apply stealth effect if not already stealthed (alpha is 1.0)
                if current_alpha >= 0.9 {
                    // Semi-transparent with darker tint for stealth
                    let color = Color::srgba(
                        current_color.red * 0.6,
                        current_color.green * 0.6,
                        current_color.blue * 0.6,
                        0.4, // 40% opacity
                    );
                    material.base_color = color;
                }
            } else {
                // Only restore if currently stealthed (alpha is low)
                if current_alpha < 0.9 {
                    // Restore original color by reversing the darkening (divide by 0.6)
                    let color = Color::srgba(
                        (current_color.red / 0.6).min(1.0),
                        (current_color.green / 0.6).min(1.0),
                        (current_color.blue / 0.6).min(1.0),
                        1.0, // Full opacity
                    );
                    material.base_color = color;
                }
            }
        }
    }
}

/// Auto-attack system: Process attacks based on attack speed timers.
/// 
/// Each combatant has an attack timer that counts up. When it reaches
/// the attack interval (1.0 / attack_speed), they check if they're in
/// range and attack their target.
/// 
/// **Range Check**: Only melee attacks for now, must be within MELEE_RANGE.
/// **WoW Mechanic**: Cannot auto-attack while casting (checked via `CastingState`).
/// 
/// Damage is applied immediately and stats are updated for both attacker and target.
/// All attacks are logged to the combat log for display.
pub fn combat_auto_attack(
    countdown: Res<MatchCountdown>,
    time: Res<Time>,
    mut commands: Commands,
    mut combat_log: ResMut<CombatLog>,
    mut combatants: Query<(Entity, &Transform, &mut Combatant, Option<&CastingState>, Option<&ActiveAuras>)>,
    mut fct_states: Query<&mut FloatingTextState>,
    celebration: Option<Res<VictoryCelebration>>,
) {
    // Don't deal damage during victory celebration
    if celebration.is_some() {
        return;
    }
    let dt = time.delta_secs();
    
    // Update match time in combat log (countdown doesn't count against match time)
    if countdown.gates_opened {
        combat_log.match_time += dt;
    }
    
    // Don't allow auto-attacks until gates open
    if !countdown.gates_opened {
        return;
    }
    
    // Build a snapshot of positions for range checks
    let positions: std::collections::HashMap<Entity, Vec3> = combatants
        .iter()
        .map(|(entity, transform, _, _, _)| (entity, transform.translation))
        .collect();
    
    // Build a snapshot of combatant info for logging
    let combatant_info: std::collections::HashMap<Entity, (u8, match_config::CharacterClass)> = combatants
        .iter()
        .map(|(entity, _, combatant, _, _)| (entity, (combatant.team, combatant.class)))
        .collect();
    
    // Collect attacks that will happen this frame (attacker, target, damage)
    let mut attacks = Vec::new();
    
    // Track damage per target for batching floating combat text
    let mut damage_per_target: std::collections::HashMap<Entity, f32> = std::collections::HashMap::new();
    // Track damage per target for aura breaking
    let mut damage_per_aura_break: std::collections::HashMap<Entity, f32> = std::collections::HashMap::new();
    
    for (attacker_entity, transform, mut combatant, casting_state, auras) in combatants.iter_mut() {
        if !combatant.is_alive() {
            continue;
        }
        
        // WoW Mechanic: Cannot auto-attack while stunned
        let is_stunned = if let Some(auras) = auras {
            auras.auras.iter().any(|a| a.effect_type == AuraType::Stun)
        } else {
            false
        };
        if is_stunned {
            continue;
        }
        
        // WoW Mechanic: Cannot auto-attack while casting
        if casting_state.is_some() {
            continue;
        }
        
        // WoW Mechanic: Cannot auto-attack while stealthed (Rogues must use abilities)
        if combatant.stealthed {
            continue;
        }

        // Update attack timer
        combatant.attack_timer += dt;

        // Check if ready to attack and has a target
        let attack_interval = 1.0 / combatant.attack_speed;
        if combatant.attack_timer >= attack_interval {
            if let Some(target_entity) = combatant.target {
                // Check if target is in range before attacking
                if let Some(&target_pos) = positions.get(&target_entity) {
                    let my_pos = transform.translation;
                    
                    if combatant.in_attack_range(my_pos, target_pos) {
                        // Calculate total damage (base + bonus from Heroic Strike, etc.)
                        let total_damage = combatant.attack_damage + combatant.next_attack_bonus_damage;
                        let has_bonus = combatant.next_attack_bonus_damage > 0.0;
                        
                        attacks.push((attacker_entity, target_entity, total_damage, has_bonus));
                        combatant.attack_timer = 0.0;
                        
                        // Consume the bonus damage after queueing the attack
                        combatant.next_attack_bonus_damage = 0.0;
                        
                        // Break stealth on auto-attack
                        if combatant.stealthed {
                            combatant.stealthed = false;
                            info!(
                                "Team {} {} breaks stealth with auto-attack!",
                                combatant.team,
                                combatant.class.name()
                            );
                        }
                        
                        // Warriors generate Rage from auto-attacks
                        if combatant.resource_type == ResourceType::Rage {
                            let rage_gain = 10.0; // Gain 10 rage per auto-attack
                            combatant.current_mana = (combatant.current_mana + rage_gain).min(combatant.max_mana);
                        }
                    }
                    // If not in range, timer keeps building up so they attack immediately when in range
                }
            }
        }
    }

    // Apply damage to targets and track damage dealt
    let mut damage_dealt_updates: Vec<(Entity, f32)> = Vec::new();
    
    for (attacker_entity, target_entity, damage, has_bonus) in attacks {
        if let Ok((_, _, mut target, _, _)) = combatants.get_mut(target_entity) {
            if target.is_alive() {
                let actual_damage = damage.min(target.current_health);
                target.current_health = (target.current_health - damage).max(0.0);
                target.damage_taken += actual_damage;
                
                // Warriors generate Rage from taking damage
                if target.resource_type == ResourceType::Rage {
                    let rage_gain = actual_damage * 0.15; // Gain 15% of damage taken as Rage
                    target.current_mana = (target.current_mana + rage_gain).min(target.max_mana);
                }
                
                // Track damage for aura breaking
                *damage_per_aura_break.entry(target_entity).or_insert(0.0) += actual_damage;
                
                // Batch damage for floating combat text (sum all damage to same target)
                *damage_per_target.entry(target_entity).or_insert(0.0) += actual_damage;
                
                // Collect attacker damage for later update
                damage_dealt_updates.push((attacker_entity, actual_damage));
                
                // Log the attack with position data
                if let (Some(&(attacker_team, attacker_class)), Some(&(target_team, target_class))) = 
                    (combatant_info.get(&attacker_entity), combatant_info.get(&target_entity)) {
                    let attack_name = if has_bonus {
                        "Heroic Strike" // Enhanced auto-attack
                    } else {
                        // Distinguish between melee and wand attacks based on class
                        match attacker_class {
                            match_config::CharacterClass::Mage | match_config::CharacterClass::Priest => "Wand Shot",
                            _ => "Auto Attack",
                        }
                    };
                    let message = format!(
                        "Team {} {}'s {} hits Team {} {} for {:.0} damage",
                        attacker_team,
                        attacker_class.name(),
                        attack_name,
                        target_team,
                        target_class.name(),
                        actual_damage
                    );
                    
                    // Get positions for logging
                    if let (Some(&attacker_pos), Some(&target_pos)) = 
                        (positions.get(&attacker_entity), positions.get(&target_entity)) {
                        let distance = attacker_pos.distance(target_pos);
                        combat_log.log_with_position(
                            CombatLogEventType::Damage,
                            message,
                            PositionData {
                                entities: vec![
                                    format!("Team {} {} (attacker)", attacker_team, attacker_class.name()),
                                    format!("Team {} {} (target)", target_team, target_class.name()),
                                ],
                                positions: vec![
                                    (attacker_pos.x, attacker_pos.y, attacker_pos.z),
                                    (target_pos.x, target_pos.y, target_pos.z),
                                ],
                                distance: Some(distance),
                            },
                        );
                    } else {
                        combat_log.log(CombatLogEventType::Damage, message);
                    }
                }
                
                if !target.is_alive() {
                    // Log death
                    if let Some(&(target_team, target_class)) = combatant_info.get(&target_entity) {
                        let message = format!(
                            "Team {} {} has been eliminated",
                            target_team,
                            target_class.name()
                        );
                        combat_log.log(CombatLogEventType::Death, message);
                    }
                }
            }
        }
    }
    
    // Spawn floating combat text for each target that took damage (batched)
    for (target_entity, total_damage) in damage_per_target {
        if let Some(&target_pos) = positions.get(&target_entity) {
            // Spawn floating text slightly above the combatant
            let text_position = target_pos + Vec3::new(0.0, 2.0, 0.0);
            
            // Get deterministic offset based on pattern state
            let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                get_next_fct_offset(&mut fct_state)
            } else {
                // Fallback to center if state not found
                (0.0, 0.0)
            };
            
            commands.spawn((
                FloatingCombatText {
                    world_position: text_position + Vec3::new(offset_x, offset_y, 0.0),
                    text: format!("{:.0}", total_damage),
                    color: egui::Color32::WHITE, // White for auto-attacks
                    lifetime: 1.5, // Display for 1.5 seconds
                    vertical_offset: offset_y,
                },
                PlayMatchEntity,
            ));
        }
    }
    
    // Update attacker damage dealt stats
    for (attacker_entity, damage) in damage_dealt_updates {
        if let Ok((_, _, mut attacker, _, _)) = combatants.get_mut(attacker_entity) {
            attacker.damage_dealt += damage;
        }
    }
    
    // Track damage for aura breaking
    for (target_entity, total_damage) in damage_per_aura_break {
        commands.entity(target_entity).insert(DamageTakenThisFrame {
            amount: total_damage,
        });
    }
}

/// Resource regeneration system: Regenerate mana for all combatants.
/// 
/// Each combatant with mana regeneration gains mana per second up to their max.
/// Also ticks down ability cooldowns over time.
pub fn regenerate_resources(
    time: Res<Time>,
    mut combatants: Query<&mut Combatant>,
) {
    let dt = time.delta_secs();
    
    for mut combatant in combatants.iter_mut() {
        if !combatant.is_alive() {
            continue;
        }
        
        // Regenerate mana/resources
        if combatant.mana_regen > 0.0 {
            combatant.current_mana = (combatant.current_mana + combatant.mana_regen * dt).min(combatant.max_mana);
        }
        
        // Tick down ability cooldowns
        let abilities_on_cooldown: Vec<AbilityType> = combatant.ability_cooldowns.keys().copied().collect();
        for ability in abilities_on_cooldown {
            if let Some(cooldown) = combatant.ability_cooldowns.get_mut(&ability) {
                *cooldown -= dt;
                if *cooldown <= 0.0 {
                    combatant.ability_cooldowns.remove(&ability);
                }
            }
        }
        
        // Tick down global cooldown
        if combatant.global_cooldown > 0.0 {
            combatant.global_cooldown -= dt;
            if combatant.global_cooldown < 0.0 {
                combatant.global_cooldown = 0.0;
            }
        }
        
        // Tick down kiting timer
        if combatant.kiting_timer > 0.0 {
            combatant.kiting_timer -= dt;
            if combatant.kiting_timer < 0.0 {
                combatant.kiting_timer = 0.0;
            }
        }
    }
}

/// Ability decision system: AI decides when to cast abilities.
/// 
/// - **Mages**: Cast Frostbolt on enemies when in range and have mana
/// - **Priests**: Cast Flash Heal on lowest HP ally (including self) when needed
/// - **Rogues**: Use Ambush from stealth for high burst damage
/// 
/// Future: More complex decision trees, cooldowns, priorities, etc.
pub fn decide_abilities(
    mut commands: Commands,
    mut combat_log: ResMut<CombatLog>,
    mut combatants: Query<(Entity, &mut Combatant, &Transform, Option<&ActiveAuras>), Without<CastingState>>,
    mut fct_states: Query<&mut FloatingTextState>,
    celebration: Option<Res<VictoryCelebration>>,
) {
    // Don't cast abilities during victory celebration
    if celebration.is_some() {
        return;
    }
    // Build position and info maps from all combatants
    let positions: std::collections::HashMap<Entity, Vec3> = combatants
        .iter()
        .map(|(entity, _, transform, _)| (entity, transform.translation))
        .collect();
    
    let combatant_info: std::collections::HashMap<Entity, (u8, match_config::CharacterClass, f32, f32)> = combatants
        .iter()
        .map(|(entity, combatant, _, _)| {
            (entity, (combatant.team, combatant.class, combatant.current_health, combatant.max_health))
        })
        .collect();
    
    // Map of entities to their active auras (for checking buffs/debuffs)
    let active_auras_map: std::collections::HashMap<Entity, Vec<Aura>> = combatants
        .iter()
        .filter_map(|(entity, _, _, auras_opt)| {
            auras_opt.map(|auras| (entity, auras.auras.clone()))
        })
        .collect();
    
    // Queue for Ambush attacks (attacker, target, damage, team, class)
    // Queue for instant ability attacks (Ambush, Sinister Strike, Mortal Strike)
    // Format: (attacker_entity, target_entity, damage, attacker_team, attacker_class, ability_type)
    let mut instant_attacks: Vec<(Entity, Entity, f32, u8, match_config::CharacterClass, AbilityType)> = Vec::new();
    
    // Queue for Frost Nova damage (caster, target, damage, caster_team, caster_class, target_pos)
    let mut frost_nova_damage: Vec<(Entity, Entity, f32, u8, match_config::CharacterClass, Vec3)> = Vec::new();
    
    for (entity, mut combatant, transform, auras) in combatants.iter_mut() {
        if !combatant.is_alive() {
            continue;
        }
        
        // WoW Mechanic: Cannot use abilities while stunned
        let is_stunned = if let Some(auras) = auras {
            auras.auras.iter().any(|a| a.effect_type == AuraType::Stun)
        } else {
            false
        };
        if is_stunned {
            continue;
        }
        
        let my_pos = transform.translation;
        
        // Mages cast spells on enemies
        if combatant.class == match_config::CharacterClass::Mage {
            // Check if global cooldown is active
            if combatant.global_cooldown > 0.0 {
                continue; // Can't use abilities during GCD
            }
            
            // First priority: Use Frost Nova if enemies are in melee range (defensive ability)
            let frost_nova = AbilityType::FrostNova;
            let nova_def = frost_nova.definition();
            let nova_on_cooldown = combatant.ability_cooldowns.contains_key(&frost_nova);
            
            // Check if Frost school is locked out
            let frost_locked_out = is_spell_school_locked(nova_def.spell_school, auras);
            
            if !nova_on_cooldown && !frost_locked_out && combatant.current_mana >= nova_def.mana_cost {
                // Check if any enemies are within Frost Nova range (melee range for threat detection)
                let enemies_in_melee_range = positions.iter().any(|(enemy_entity, &enemy_pos)| {
                    if let Some(&(enemy_team, _, _, _)) = combatant_info.get(enemy_entity) {
                        if enemy_team != combatant.team {
                            let distance = my_pos.distance(enemy_pos);
                            return distance <= MELEE_RANGE;
                        }
                    }
                    false
                });
                
                if enemies_in_melee_range {
                    // Consume mana
                    combatant.current_mana -= nova_def.mana_cost;
                    
                    // Put ability on cooldown
                    combatant.ability_cooldowns.insert(frost_nova, nova_def.cooldown);
                    
                    // Trigger global cooldown (1.5s standard WoW GCD)
                    combatant.global_cooldown = 1.5;
                    
                    // Collect enemies in range for damage and root
                    let mut frost_nova_targets: Vec<(Entity, Vec3, u8, match_config::CharacterClass)> = Vec::new();
                    for (enemy_entity, &enemy_pos) in positions.iter() {
                        if let Some(&(enemy_team, enemy_class, _, _)) = combatant_info.get(enemy_entity) {
                            if enemy_team != combatant.team {
                                let distance = my_pos.distance(enemy_pos);
                                if distance <= nova_def.range {
                                    frost_nova_targets.push((*enemy_entity, enemy_pos, enemy_team, enemy_class));
                                }
                            }
                        }
                    }
                    
                    // Queue damage and apply root to all targets
                    for (target_entity, target_pos, target_team, target_class) in &frost_nova_targets {
                        // Calculate damage (with stat scaling)
                        let damage = combatant.calculate_ability_damage(&nova_def);
                        
                        // Queue damage for later application
                        frost_nova_damage.push((entity, *target_entity, damage, combatant.team, combatant.class, *target_pos));
                        
                        // Apply aura (spawn separate AuraPending entity)
                        if let Some((aura_type, duration, magnitude, break_threshold)) = nova_def.applies_aura {
                            commands.spawn(AuraPending {
                                target: *target_entity,
                                aura: Aura {
                                    effect_type: aura_type,
                                    duration,
                                    magnitude,
                                    break_on_damage_threshold: break_threshold,
                                    accumulated_damage: 0.0,
                                    tick_interval: 0.0,
                                    time_until_next_tick: 0.0,
                                    caster: Some(entity),
                                },
                            });
                        }
                    }
                    
                    // Set kiting timer - mage should move away from enemies for the root duration
                    combatant.kiting_timer = nova_def.applies_aura.unwrap().1; // Root duration (6.0s)
                    
                    info!(
                        "Team {} {} casts Frost Nova! (AOE root) - {} enemies affected",
                        combatant.team,
                        combatant.class.name(),
                        frost_nova_targets.len()
                    );
                    
                    continue; // Don't cast Frostbolt this frame
                }
            }
            
            // Second priority: Cast Frostbolt on target
            // While kiting, only cast if we're at a safe distance (beyond melee range + buffer)
            let Some(target_entity) = combatant.target else {
                continue;
            };
            
            let Some(&target_pos) = positions.get(&target_entity) else {
                continue;
            };
            
            let distance_to_target = my_pos.distance(target_pos);
            
            // While kiting, only cast if we're at a safe distance
            // Safe distance = beyond melee range + buffer (8 units gives good tactical spacing)
            const SAFE_KITING_DISTANCE: f32 = 8.0;
            if combatant.kiting_timer > 0.0 && distance_to_target < SAFE_KITING_DISTANCE {
                continue; // Too close while kiting, focus on movement
            }
            
            // Check if global cooldown is active
            if combatant.global_cooldown > 0.0 {
                continue; // Can't start casting during GCD
            }
            
            // Try to cast Frostbolt
            let ability = AbilityType::Frostbolt;
            let def = ability.definition();
            
            // Check if spell school is locked out
            if is_spell_school_locked(def.spell_school, auras) {
                continue; // Can't cast - spell school is locked
            }
            
            if ability.can_cast(&combatant, target_pos, my_pos) {
                let def = ability.definition();
                
                // Trigger global cooldown (1.5s standard WoW GCD)
                // GCD starts when cast BEGINS, not when it completes
                combatant.global_cooldown = 1.5;
                
                // Start casting
                commands.entity(entity).insert(CastingState {
                    ability,
                    time_remaining: def.cast_time,
                    target: Some(target_entity),
                    interrupted: false,
                    interrupted_display_time: 0.0,
                });
                
                info!(
                    "Team {} {} starts casting {} on enemy",
                    combatant.team,
                    combatant.class.name(),
                    def.name
                );
            }
        }
        // Priests cast Flash Heal on injured allies
        else if combatant.class == match_config::CharacterClass::Priest {
            // Check if global cooldown is active (check once for all abilities)
            if combatant.global_cooldown > 0.0 {
                continue; // Can't cast during GCD
            }
            
            // Priority 0: Cast Power Word: Fortitude on allies who don't have it
            // (Pre-combat buffing phase)
            let mut unbuffed_ally: Option<(Entity, Vec3)> = None;
            
            for (ally_entity, &(ally_team, _ally_class, ally_hp, _ally_max_hp)) in combatant_info.iter() {
                // Must be same team and alive
                if ally_team != combatant.team || ally_hp <= 0.0 {
                    continue;
                }
                
                // Check if ally already has MaxHealthIncrease buff
                let has_fortitude = if let Some(auras) = active_auras_map.get(ally_entity) {
                    auras.iter().any(|a| a.effect_type == AuraType::MaxHealthIncrease)
                } else {
                    false
                };
                
                if has_fortitude {
                    continue; // Already buffed
                }
                
                // Get position
                let Some(&ally_pos) = positions.get(ally_entity) else {
                    continue;
                };
                
                // Found an unbuffed ally
                unbuffed_ally = Some((*ally_entity, ally_pos));
                break; // Buff one ally at a time
            }
            
            // Cast Fortitude on unbuffed ally
            if let Some((buff_target, target_pos)) = unbuffed_ally {
                let ability = AbilityType::PowerWordFortitude;
                let def = ability.definition();
                
                // Check if spell school is locked out
                if !is_spell_school_locked(def.spell_school, auras) && ability.can_cast(&combatant, target_pos, my_pos) {
                    let def = ability.definition();
                    
                    // Consume mana
                    combatant.current_mana -= def.mana_cost;
                    
                    // Trigger global cooldown
                    combatant.global_cooldown = 1.5;
                    
                    // Apply the buff aura immediately (instant cast)
                    if let Some((aura_type, duration, magnitude, break_threshold)) = def.applies_aura {
                        commands.spawn(AuraPending {
                            target: buff_target,
                            aura: Aura {
                                effect_type: aura_type,
                                duration,
                                magnitude,
                                break_on_damage_threshold: break_threshold,
                                accumulated_damage: 0.0,
                                tick_interval: 0.0,
                                time_until_next_tick: 0.0,
                                caster: Some(entity),
                            },
                        });
                    }
                    
                    info!(
                        "Team {} {} casts Power Word: Fortitude on ally",
                        combatant.team,
                        combatant.class.name()
                    );
                    
                    continue; // Done this frame
                }
            }
            
            // Find the lowest HP ally (including self)
            let mut lowest_hp_ally: Option<(Entity, f32, Vec3)> = None;
            
            for (ally_entity, &(ally_team, _ally_class, ally_hp, ally_max_hp)) in combatant_info.iter() {
                // Must be same team and alive
                if ally_team != combatant.team {
                    continue;
                }
                
                // Only heal if damaged (below 90% health)
                let hp_percent = ally_hp / ally_max_hp;
                if hp_percent >= 0.9 {
                    continue;
                }
                
                // Get position
                let Some(&ally_pos) = positions.get(ally_entity) else {
                    continue;
                };
                
                // Track lowest HP ally
                match lowest_hp_ally {
                    None => lowest_hp_ally = Some((*ally_entity, hp_percent, ally_pos)),
                    Some((_, lowest_percent, _)) if hp_percent < lowest_percent => {
                        lowest_hp_ally = Some((*ally_entity, hp_percent, ally_pos));
                    }
                    _ => {}
                }
            }
            
            // Priority 1: Cast heal on lowest HP ally if found
            if let Some((heal_target, _, target_pos)) = lowest_hp_ally {
                let ability = AbilityType::FlashHeal;
                let def = ability.definition();
                
                // Check if spell school is locked out
                if !is_spell_school_locked(def.spell_school, auras) && ability.can_cast(&combatant, target_pos, my_pos) {
                    let def = ability.definition();
                    
                    // Trigger global cooldown (1.5s standard WoW GCD)
                    // GCD starts when cast BEGINS, not when it completes
                    combatant.global_cooldown = 1.5;
                    
                    // Start casting
                    commands.entity(entity).insert(CastingState {
                        ability,
                        time_remaining: def.cast_time,
                        target: Some(heal_target),
                        interrupted: false,
                        interrupted_display_time: 0.0,
                    });
                    
                    info!(
                        "Team {} {} starts casting {} on ally",
                        combatant.team,
                        combatant.class.name(),
                        def.name
                    );
                    
                    continue; // Done this frame
                }
            }
            
            // Priority 2: Cast Mind Blast on enemy if no healing needed
            let Some(target_entity) = combatant.target else {
                continue;
            };
            
            let Some(&target_pos) = positions.get(&target_entity) else {
                continue;
            };
            
            // Check if Mind Blast is off cooldown
            let ability = AbilityType::MindBlast;
            let on_cooldown = combatant.ability_cooldowns.contains_key(&ability);
            let def = ability.definition();
            
            // Check if spell school is locked out
            if !on_cooldown && !is_spell_school_locked(def.spell_school, auras) && ability.can_cast(&combatant, target_pos, my_pos) {
                let def = ability.definition();
                
                // Put on cooldown
                combatant.ability_cooldowns.insert(ability, def.cooldown);
                
                // Trigger global cooldown (1.5s standard WoW GCD)
                // GCD starts when cast BEGINS, not when it completes
                combatant.global_cooldown = 1.5;
                
                // Start casting
                commands.entity(entity).insert(CastingState {
                    ability,
                    time_remaining: def.cast_time,
                    target: Some(target_entity),
                    interrupted: false,
                    interrupted_display_time: 0.0,
                });
                
                info!(
                    "Team {} {} starts casting {} on enemy",
                    combatant.team,
                    combatant.class.name(),
                    def.name
                );
            }
        }
        
        // Warriors use Charge (gap closer), Mortal Strike, Rend, and Heroic Strike
        if combatant.class == match_config::CharacterClass::Warrior {
            // Check if we have an enemy target
            let Some(target_entity) = combatant.target else {
                continue;
            };
            
            let Some(&target_pos) = positions.get(&target_entity) else {
                continue;
            };
            
            let distance_to_target = my_pos.distance(target_pos);
            
            // NOTE: Interrupt checking (Pummel) is now handled in the dedicated check_interrupts system
            // which runs after apply_deferred so it can see CastingState components from this frame
            
            // Check if global cooldown is active for other abilities
            if combatant.global_cooldown > 0.0 {
                continue; // Can't use other abilities during GCD
            }
            
            // Priority 1: Use Charge to close distance if target is at medium range
            // Charge requirements:
            // - Minimum 8 units (can't waste at melee range)
            // - Maximum 25 units (ability range)
            // - Not rooted (can't charge while rooted)
            // - Off cooldown
            const CHARGE_MIN_RANGE: f32 = 8.0;
            let charge = AbilityType::Charge;
            let charge_def = charge.definition();
            let charge_on_cooldown = combatant.ability_cooldowns.contains_key(&charge);
            
            // Check if rooted
            let is_rooted = if let Some(auras) = auras {
                auras.auras.iter().any(|aura| matches!(aura.effect_type, AuraType::Root))
            } else {
                false
            };
            
            if !charge_on_cooldown 
                && !is_rooted
                && distance_to_target >= CHARGE_MIN_RANGE 
                && distance_to_target <= charge_def.range {
                
                // Use Charge!
                combatant.ability_cooldowns.insert(charge, charge_def.cooldown);
                combatant.global_cooldown = 1.5;
                
                // Add ChargingState component to enable high-speed movement
                commands.entity(entity).insert(ChargingState {
                    target: target_entity,
                });
                
                info!(
                    "Team {} {} uses {} on enemy (distance: {:.1} units)",
                    combatant.team,
                    combatant.class.name(),
                    charge_def.name,
                    distance_to_target
                );
                
                continue; // Done this frame
            }
            
            // Priority 2: Apply Rend if target doesn't have it
            let target_has_rend = if let Some(auras) = active_auras_map.get(&target_entity) {
                auras.iter().any(|a| a.effect_type == AuraType::DamageOverTime)
            } else {
                false
            };
            
            if !target_has_rend {
                let rend = AbilityType::Rend;
                let rend_def = rend.definition();
                let can_cast_rend = rend.can_cast(&combatant, target_pos, my_pos);
                
                if can_cast_rend {
                    // Consume rage
                    combatant.current_mana -= rend_def.mana_cost;
                    
                    // Trigger global cooldown
                    combatant.global_cooldown = 1.5;
                    
                    // Apply the DoT aura
                    if let Some((aura_type, duration, magnitude, break_threshold)) = rend_def.applies_aura {
                        commands.spawn(AuraPending {
                            target: target_entity,
                            aura: Aura {
                                effect_type: aura_type,
                                duration,
                                magnitude,
                                break_on_damage_threshold: break_threshold,
                                accumulated_damage: 0.0,
                                tick_interval: 3.0, // Tick every 3 seconds
                                time_until_next_tick: 3.0, // First tick after 3 seconds
                                caster: Some(entity),
                            },
                        });
                    }
                    
                    // Log Rend application to combat log
                    combat_log.log(
                        CombatLogEventType::Buff,
                        format!(
                            "Team {} {} applies Rend to enemy (8 damage per 3s for 15s)",
                            combatant.team,
                            combatant.class.name()
                        )
                    );
                    
                    info!(
                        "Team {} {} applies Rend to enemy (8 damage per 3s for 15s)",
                        combatant.team,
                        combatant.class.name()
                    );
                    
                    continue; // Done this frame
                }
            }
            
            // Priority 3: Use Mortal Strike if off cooldown and enough rage (high priority cooldown)
            let mortal_strike = AbilityType::MortalStrike;
            let ms_def = mortal_strike.definition();
            let ms_on_cooldown = combatant.ability_cooldowns.contains_key(&mortal_strike);
            let can_cast_ms = mortal_strike.can_cast(&combatant, target_pos, my_pos);
            
            if !ms_on_cooldown && can_cast_ms && combatant.current_mana >= ms_def.mana_cost {
                // Get target info
                let (target_team, target_class) = if let Some(&(team, class, _, _)) = combatant_info.get(&target_entity) {
                    (team, class)
                } else {
                    continue;
                };
                
                // Consume rage
                combatant.current_mana -= ms_def.mana_cost;
                
                // Put on cooldown
                combatant.ability_cooldowns.insert(mortal_strike, ms_def.cooldown);
                
                // Trigger global cooldown
                combatant.global_cooldown = 1.5;
                
                // Calculate damage
                let damage = combatant.calculate_ability_damage(&ms_def);
                
                // Queue damage to apply (collect for later to avoid borrow issues)
                instant_attacks.push((entity, target_entity, damage, combatant.team, combatant.class, mortal_strike));
                
                // Apply healing reduction aura
                if let Some((aura_type, duration, magnitude, break_threshold)) = ms_def.applies_aura {
                    commands.spawn(AuraPending {
                        target: target_entity,
                        aura: Aura {
                            effect_type: aura_type,
                            duration,
                            magnitude,
                            break_on_damage_threshold: break_threshold,
                            accumulated_damage: 0.0,
                            tick_interval: 0.0,
                            time_until_next_tick: 0.0,
                            caster: Some(entity),
                        },
                    });
                }
                
                // Log to combat log
                let message = format!(
                    "Team {} {}'s Mortal Strike hits Team {} {} for {:.0} damage",
                    combatant.team,
                    combatant.class.name(),
                    target_team,
                    target_class.name(),
                    damage
                );
                
                if let (Some(&attacker_pos), Some(&target_pos_val)) = 
                    (positions.get(&entity), positions.get(&target_entity)) {
                    let distance = attacker_pos.distance(target_pos_val);
                    combat_log.log_with_position(
                        CombatLogEventType::Damage,
                        message,
                        PositionData {
                            entities: vec![
                                format!("Team {} {} (attacker)", combatant.team, combatant.class.name()),
                                format!("Team {} {} (target)", target_team, target_class.name()),
                            ],
                            positions: vec![
                                (attacker_pos.x, attacker_pos.y, attacker_pos.z),
                                (target_pos_val.x, target_pos_val.y, target_pos_val.z),
                            ],
                            distance: Some(distance),
                        },
                    );
                }
                
                info!(
                    "Team {} {} uses Mortal Strike for {:.0} damage!",
                    combatant.team,
                    combatant.class.name(),
                    damage
                );
                
                // Spawn floating combat text (yellow for abilities)
                // Get deterministic offset based on pattern state
                let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                    get_next_fct_offset(&mut fct_state)
                } else {
                    (0.0, 0.0)
                };
                commands.spawn((
                    FloatingCombatText {
                        world_position: target_pos + Vec3::new(offset_x, 2.0 + offset_y, 0.0),
                        text: format!("{:.0}", damage),
                        color: egui::Color32::from_rgb(255, 255, 100), // Yellow for abilities
                        lifetime: 1.5,
                        vertical_offset: offset_y,
                    },
                    PlayMatchEntity,
                ));
                
                continue; // Done this frame
            }
            
            // Priority 4: Use Heroic Strike if target is in melee range
            // Only use Heroic Strike if we have excess rage (save rage for Rend/Pummel/MortalStrike)
            // Don't queue another Heroic Strike if one is already pending
            if combatant.next_attack_bonus_damage > 0.0 {
                continue;
            }
            
            // Try to use Heroic Strike if we have enough rage and target is in melee range
            let ability = AbilityType::HeroicStrike;
            let def = ability.definition();
            
            // Only use if we have enough rage for both Heroic Strike AND Rend+Pummel+MortalStrike reserve
            // Reserve: 10 (Rend) + 10 (Pummel) + 30 (Mortal Strike) = 50 rage minimum
            const RAGE_RESERVE: f32 = 50.0;
            let can_afford_heroic_strike = combatant.current_mana >= (def.mana_cost + RAGE_RESERVE);
            
            if can_afford_heroic_strike && ability.can_cast(&combatant, target_pos, my_pos) {
                // Since it's instant, apply the effect immediately
                // Consume rage
                combatant.current_mana -= def.mana_cost;
                
                // Set bonus damage for next auto-attack (50% of base attack damage)
                let bonus_damage = combatant.attack_damage * 0.5;
                combatant.next_attack_bonus_damage = bonus_damage;
                
                // Trigger global cooldown (1.5s standard WoW GCD)
                combatant.global_cooldown = 1.5;
                
                info!(
                    "Team {} {} uses {} (next attack +{:.0} damage)",
                    combatant.team,
                    combatant.class.name(),
                    def.name,
                    bonus_damage
                );
            }
        }
        
        // Rogues use Ambush from stealth (instant ability, high damage)
        if combatant.class == match_config::CharacterClass::Rogue && combatant.stealthed {
            // Check if we have an enemy target
            let Some(target_entity) = combatant.target else {
                continue;
            };
            
            let Some(&target_pos) = positions.get(&target_entity) else {
                continue;
            };
            
            // Try to use Ambush if we have enough energy and target is in melee range
            let ability = AbilityType::Ambush;
            if ability.can_cast(&combatant, target_pos, my_pos) {
                let def = ability.definition();
                
                // Consume energy
                combatant.current_mana -= def.mana_cost;
                
                // Break stealth immediately
                combatant.stealthed = false;
                
                // Calculate damage (with stat scaling)
                let damage = combatant.calculate_ability_damage(&def);
                
                // Queue the Ambush attack to be applied after the loop
                instant_attacks.push((entity, target_entity, damage, combatant.team, combatant.class, ability));
                
                // Trigger global cooldown (1.5s standard WoW GCD)
                combatant.global_cooldown = 1.5;
                
                info!(
                    "Team {} {} uses {} from stealth!",
                    combatant.team,
                    combatant.class.name(),
                    def.name
                );
            }
        }
        
        // Rogues use Kick, Kidney Shot and Sinister Strike when out of stealth
        if combatant.class == match_config::CharacterClass::Rogue && !combatant.stealthed {
            // Check if we have an enemy target
            let Some(target_entity) = combatant.target else {
                continue;
            };
            
            let Some(&target_pos) = positions.get(&target_entity) else {
                continue;
            };
            
            // NOTE: Interrupt checking (Kick) is now handled in the dedicated check_interrupts system
            // which runs after apply_deferred so it can see CastingState components from this frame
            
            // Check if global cooldown is active for other abilities
            if combatant.global_cooldown > 0.0 {
                continue; // Can't use other abilities during GCD
            }
            
            // Priority 1: Use Kidney Shot (stun) if available
            let kidney_shot = AbilityType::KidneyShot;
            let ks_on_cooldown = combatant.ability_cooldowns.contains_key(&kidney_shot);
            
            if !ks_on_cooldown && kidney_shot.can_cast(&combatant, target_pos, my_pos) {
                let def = kidney_shot.definition();
                
                // Consume energy
                combatant.current_mana -= def.mana_cost;
                
                // Put on cooldown
                combatant.ability_cooldowns.insert(kidney_shot, def.cooldown);
                
                // Trigger global cooldown
                combatant.global_cooldown = 1.5;
                
                // Spawn pending aura (stun effect)
                if let Some((aura_type, duration, magnitude, break_threshold)) = def.applies_aura {
                    commands.spawn(AuraPending {
                        target: target_entity,
                        aura: Aura {
                            effect_type: aura_type,
                            duration,
                            magnitude,
                            break_on_damage_threshold: break_threshold,
                            accumulated_damage: 0.0,
                            tick_interval: 0.0,
                            time_until_next_tick: 0.0,
                            caster: Some(entity),
                        },
                    });
                }
                
                info!(
                    "Team {} {} uses {} on enemy!",
                    combatant.team,
                    combatant.class.name(),
                    def.name
                );
                
                // Log to combat log
                let message = format!(
                    "Team {} {} uses {} on Team {} {}",
                    combatant.team,
                    combatant.class.name(),
                    def.name,
                    combatant_info.get(&target_entity).map(|(t, _, _, _)| *t).unwrap_or(0),
                    combatant_info.get(&target_entity).map(|(_, c, _, _)| c.name()).unwrap_or("Unknown")
                );
                combat_log.log(CombatLogEventType::CrowdControl, message);
                
                continue; // Done this frame
            }
            
            // Priority 2: Use Sinister Strike if we have enough energy and target is in melee range
            let ability = AbilityType::SinisterStrike;
            if ability.can_cast(&combatant, target_pos, my_pos) {
                let def = ability.definition();
                
                // Consume energy
                combatant.current_mana -= def.mana_cost;
                
                // Calculate damage (with stat scaling)
                let damage = combatant.calculate_ability_damage(&def);
                
                // Queue the Sinister Strike attack to be applied after the loop
                instant_attacks.push((entity, target_entity, damage, combatant.team, combatant.class, ability));
                
                // Trigger global cooldown (1.5s standard WoW GCD)
                combatant.global_cooldown = 1.5;
                
                info!(
                    "Team {} {} uses {}!",
                    combatant.team,
                    combatant.class.name(),
                    def.name
                );
            }
        }
    }
    
    // Process queued instant attacks (Ambush, Sinister Strike)
    for (attacker_entity, target_entity, damage, attacker_team, attacker_class, ability) in instant_attacks {
        let ability_name = ability.definition().name;
        let mut actual_damage = 0.0;
        let mut target_team = 0;
        let mut target_class = match_config::CharacterClass::Warrior; // Default, will be overwritten
        
        if let Ok((_, mut target, target_transform, _)) = combatants.get_mut(target_entity) {
            if target.is_alive() {
                actual_damage = damage.min(target.current_health);
                target.current_health = (target.current_health - damage).max(0.0);
                target.damage_taken += actual_damage;
                target_team = target.team;
                target_class = target.class;
                
                // Warriors generate Rage from taking damage
                if target.resource_type == ResourceType::Rage {
                    let rage_gain = actual_damage * 0.15;
                    target.current_mana = (target.current_mana + rage_gain).min(target.max_mana);
                }
                
                // Track damage for aura breaking
                commands.entity(target_entity).insert(DamageTakenThisFrame {
                    amount: actual_damage,
                });
                
                info!(
                    "Team {} {}'s {} hits Team {} {} for {:.0} damage!",
                    attacker_team,
                    attacker_class.name(),
                    ability_name,
                    target_team,
                    target_class.name(),
                    actual_damage
                );
                
                // Spawn floating combat text (yellow for abilities)
                let text_position = target_transform.translation + Vec3::new(0.0, 2.0, 0.0);
                // Get deterministic offset based on pattern state
                let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                    get_next_fct_offset(&mut fct_state)
                } else {
                    (0.0, 0.0)
                };
                commands.spawn((
                    FloatingCombatText {
                        world_position: text_position + Vec3::new(offset_x, offset_y, 0.0),
                        text: format!("{:.0}", actual_damage),
                        color: egui::Color32::from_rgb(255, 255, 0), // Yellow for abilities
                        lifetime: 1.5,
                        vertical_offset: offset_y,
                    },
                    PlayMatchEntity,
                ));
                
                // Log the instant attack with position data
                let message = format!(
                    "Team {} {}'s {} hits Team {} {} for {:.0} damage",
                    attacker_team,
                    attacker_class.name(),
                    ability_name,
                    target_team,
                    target_class.name(),
                    actual_damage
                );
                
                if let (Some(&attacker_pos), Some(&target_pos)) = 
                    (positions.get(&attacker_entity), positions.get(&target_entity)) {
                    let distance = attacker_pos.distance(target_pos);
                    combat_log.log_with_position(
                        CombatLogEventType::Damage,
                        message,
                        PositionData {
                            entities: vec![
                                format!("Team {} {} (attacker)", attacker_team, attacker_class.name()),
                                format!("Team {} {} (target)", target_team, target_class.name()),
                            ],
                            positions: vec![
                                (attacker_pos.x, attacker_pos.y, attacker_pos.z),
                                (target_pos.x, target_pos.y, target_pos.z),
                            ],
                            distance: Some(distance),
                        },
                    );
                } else {
                    combat_log.log(CombatLogEventType::Damage, message);
                }
            }
        }
        
        // Update attacker's damage dealt
        if let Ok((_, mut attacker, _, _)) = combatants.get_mut(attacker_entity) {
            attacker.damage_dealt += actual_damage;
        }
    }
    
    // Process queued Frost Nova damage
    for (caster_entity, target_entity, damage, caster_team, caster_class, target_pos) in frost_nova_damage {
        let mut actual_damage = 0.0;
        let mut target_team = 0;
        let mut target_class = match_config::CharacterClass::Warrior;
        
        if let Ok((_, mut target, target_transform, _)) = combatants.get_mut(target_entity) {
            if target.is_alive() {
                actual_damage = damage.min(target.current_health);
                target.current_health = (target.current_health - damage).max(0.0);
                target.damage_taken += actual_damage;
                target_team = target.team;
                target_class = target.class;
                
                // Warriors generate Rage from taking damage
                if target.resource_type == ResourceType::Rage {
                    let rage_gain = actual_damage * 0.15;
                    target.current_mana = (target.current_mana + rage_gain).min(target.max_mana);
                }
                
                // Track damage for aura breaking
                commands.entity(target_entity).insert(DamageTakenThisFrame {
                    amount: actual_damage,
                });
                
                // Spawn floating combat text (yellow for abilities)
                let text_position = target_transform.translation + Vec3::new(0.0, 2.0, 0.0);
                // Get deterministic offset based on pattern state
                let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                    get_next_fct_offset(&mut fct_state)
                } else {
                    (0.0, 0.0)
                };
                commands.spawn((
                    FloatingCombatText {
                        world_position: text_position + Vec3::new(offset_x, offset_y, 0.0),
                        text: format!("{:.0}", actual_damage),
                        color: egui::Color32::from_rgb(255, 255, 0), // Yellow for abilities
                        lifetime: 1.5,
                        vertical_offset: offset_y,
                    },
                    PlayMatchEntity,
                ));
                
                // Log the Frost Nova damage with position data
                let message = format!(
                    "Team {} {}'s Frost Nova hits Team {} {} for {:.0} damage",
                    caster_team,
                    caster_class.name(),
                    target_team,
                    target_class.name(),
                    actual_damage
                );
                
                if let Some(&caster_pos) = positions.get(&caster_entity) {
                    let distance = caster_pos.distance(target_pos);
                    combat_log.log_with_position(
                        CombatLogEventType::Damage,
                        message,
                        PositionData {
                            entities: vec![
                                format!("Team {} {} (caster)", caster_team, caster_class.name()),
                                format!("Team {} {} (target)", target_team, target_class.name()),
                            ],
                            positions: vec![
                                (caster_pos.x, caster_pos.y, caster_pos.z),
                                (target_pos.x, target_pos.y, target_pos.z),
                            ],
                            distance: Some(distance),
                        },
                    );
                } else {
                    combat_log.log(CombatLogEventType::Damage, message);
                }
            }
        }
        
        // Update caster's damage dealt
        if let Ok((_, mut caster, _, _)) = combatants.get_mut(caster_entity) {
            caster.damage_dealt += actual_damage;
        }
    }
}

/// Casting system: Process active casts, complete them when time is up.
/// Check if any combatants should interrupt their targets
/// This runs AFTER apply_deferred so it can see CastingState components added this frame
pub fn check_interrupts(
    mut commands: Commands,
    mut combat_log: ResMut<CombatLog>,
    mut combatants: Query<(Entity, &mut Combatant, &Transform), Without<CastingState>>,
    casting_targets: Query<&CastingState>,
    positions: Query<&Transform>,
    celebration: Option<Res<VictoryCelebration>>,
) {
    // Don't interrupt during victory celebration
    if celebration.is_some() {
        return;
    }
    
    for (entity, mut combatant, transform) in combatants.iter_mut() {
        if !combatant.is_alive() {
            continue;
        }
        
        // Only Warriors and Rogues have interrupts
        if combatant.class != match_config::CharacterClass::Warrior 
            && combatant.class != match_config::CharacterClass::Rogue {
            continue;
        }
        
        let Some(target_entity) = combatant.target else {
            continue;
        };
        
        let Ok(target_transform) = positions.get(target_entity) else {
            continue;
        };
        
        let my_pos = transform.translation;
        let target_pos = target_transform.translation;
        let distance = my_pos.distance(target_pos);
        
        // Check if target is casting
        let Ok(cast_state) = casting_targets.get(target_entity) else {
            continue; // Target not casting
        };
        
        if cast_state.interrupted {
            continue; // Already interrupted
        }
        
        // Determine which interrupt ability to use based on class
        let interrupt_ability = match combatant.class {
            match_config::CharacterClass::Warrior => AbilityType::Pummel,
            match_config::CharacterClass::Rogue => AbilityType::Kick,
            _ => continue,
        };
        
        let ability_def = interrupt_ability.definition();
        
        // Check if interrupt is on cooldown
        if combatant.ability_cooldowns.contains_key(&interrupt_ability) {
            continue;
        }
        
        // Check if we can cast the interrupt (range, resources, etc.)
        if !interrupt_ability.can_cast(&combatant, target_pos, my_pos) {
            continue;
        }
        
        // Use the interrupt!
        info!(
            "[INTERRUPT] Team {} {} uses {} to interrupt {}'s cast (distance: {:.1}, time_remaining: {:.2}s)",
            combatant.team,
            combatant.class.name(),
            ability_def.name,
            cast_state.ability.definition().name,
            distance,
            cast_state.time_remaining
        );
        
        // Consume resources
        combatant.current_mana -= ability_def.mana_cost;
        
        // Put on cooldown
        combatant.ability_cooldowns.insert(interrupt_ability, ability_def.cooldown);
        
        // Interrupts do NOT trigger GCD in WoW!
        
        // Queue the interrupt for processing
        commands.spawn(InterruptPending {
            caster: entity,
            target: target_entity,
            ability: interrupt_ability,
            lockout_duration: ability_def.lockout_duration,
        });
        
        // Log to combat log
        combat_log.log(
            CombatLogEventType::AbilityUsed,
            format!(
                "Team {} {} uses {} to interrupt enemy cast",
                combatant.team,
                combatant.class.name(),
                ability_def.name
            )
        );
    }
}

/// 
/// Reduces cast timers each frame. When a cast completes:
/// Process interrupt attempts: interrupt target's cast and apply spell school lockout.
pub fn process_interrupts(
    mut commands: Commands,
    mut combat_log: ResMut<CombatLog>,
    interrupts: Query<(Entity, &InterruptPending)>,
    mut targets: Query<(&mut CastingState, &Combatant)>,
    combatants: Query<&Combatant>,
    celebration: Option<Res<VictoryCelebration>>,
) {
    // Don't process interrupts during victory celebration
    if celebration.is_some() {
        return;
    }
    
    for (interrupt_entity, interrupt) in interrupts.iter() {
        // Check if target is still casting
        if let Ok((mut cast_state, target_combatant)) = targets.get_mut(interrupt.target) {
            // Don't interrupt if already interrupted
            if cast_state.interrupted {
                commands.entity(interrupt_entity).despawn();
                continue;
            }
            
            // Get the spell school of the interrupted spell
            let interrupted_ability_def = cast_state.ability.definition();
            let interrupted_school = interrupted_ability_def.spell_school;
            let interrupted_spell_name = interrupted_ability_def.name;
            
            // Mark cast as interrupted
            cast_state.interrupted = true;
            cast_state.interrupted_display_time = 0.5; // Show "INTERRUPTED" for 0.5 seconds
            
            // Get caster info for logging
            let caster_info = if let Ok(caster) = combatants.get(interrupt.caster) {
                (caster.team, caster.class)
            } else {
                (0, match_config::CharacterClass::Warrior) // Fallback
            };
            
            // Apply spell school lockout aura
            // Store the locked school as the magnitude (cast to f32)
            let locked_school_value = match interrupted_school {
                SpellSchool::Physical => 0.0,
                SpellSchool::Frost => 1.0,
                SpellSchool::Holy => 2.0,
                SpellSchool::Shadow => 3.0,
                SpellSchool::None => 4.0,
            };
            
            commands.spawn(AuraPending {
                target: interrupt.target,
                aura: Aura {
                    effect_type: AuraType::SpellSchoolLockout,
                    duration: interrupt.lockout_duration,
                    magnitude: locked_school_value,
                    break_on_damage_threshold: 0.0,
                    accumulated_damage: 0.0,
                    tick_interval: 0.0,
                    time_until_next_tick: 0.0,
                    caster: Some(interrupt.caster),
                },
            });
            
            // Log the interrupt
            let school_name = match interrupted_school {
                SpellSchool::Physical => "Physical",
                SpellSchool::Frost => "Frost",
                SpellSchool::Holy => "Holy",
                SpellSchool::Shadow => "Shadow",
                SpellSchool::None => "None",
            };
            
            let message = format!(
                "Team {} {} interrupts Team {} {}'s {} - {} school locked for {:.1}s",
                caster_info.0,
                caster_info.1.name(),
                target_combatant.team,
                target_combatant.class.name(),
                interrupted_spell_name,
                school_name,
                interrupt.lockout_duration
            );
            combat_log.log(CombatLogEventType::AbilityUsed, message);
            
            info!(
                "Team {} {} interrupted! {} school locked for {:.1}s",
                target_combatant.team,
                target_combatant.class.name(),
                school_name,
                interrupt.lockout_duration
            );
        }
        
        // Despawn the interrupt entity
        commands.entity(interrupt_entity).despawn();
    }
}

/// Process casting: update cast timers and apply effects when casts complete.
///
/// When a cast completes:
/// 1. Consume mana
/// 2. Deal damage (for damage spells) or heal (for healing spells)
/// 3. Apply auras (if applicable)
/// 4. Spawn floating combat text (yellow for damage, green for healing)
/// 5. Log to combat log with position data
pub fn process_casting(
    time: Res<Time>,
    mut commands: Commands,
    mut combat_log: ResMut<CombatLog>,
    mut combatants: Query<(Entity, &Transform, &mut Combatant, Option<&mut CastingState>, Option<&ActiveAuras>)>,
    mut fct_states: Query<&mut FloatingTextState>,
    celebration: Option<Res<VictoryCelebration>>,
) {
    // Don't complete casts during victory celebration
    if celebration.is_some() {
        return;
    }
    
    let dt = time.delta_secs();
    
    // Track completed casts
    let mut completed_casts = Vec::new();
    
    // First pass: update cast timers and collect completed casts
    for (caster_entity, caster_transform, mut caster, casting_state, _auras) in combatants.iter_mut() {
        let Some(mut casting) = casting_state else {
            continue;
        };
        
        if !caster.is_alive() {
            // Cancel cast if caster dies
            commands.entity(caster_entity).remove::<CastingState>();
            continue;
        }
        
        // Handle interrupted casts
        if casting.interrupted {
            // Tick down the interrupted display timer
            casting.interrupted_display_time -= dt;
            
            // Remove CastingState once display time expires
            if casting.interrupted_display_time <= 0.0 {
                commands.entity(caster_entity).remove::<CastingState>();
            }
            
            // Don't process interrupted casts
            continue;
        }
        
        // Tick down cast time
        casting.time_remaining -= dt;
        
        // Check if cast completed
        if casting.time_remaining <= 0.0 {
            let ability = casting.ability;
            let def = ability.definition();
            let target_entity = casting.target;
            
            // Consume mana
            caster.current_mana -= def.mana_cost;
            
            // Pre-calculate damage/healing (using caster's stats)
            let ability_damage = caster.calculate_ability_damage(&def);
            let ability_healing = caster.calculate_ability_healing(&def);
            
            // Store cast info for processing
            completed_casts.push((
                caster_entity,
                caster.team,
                caster.class,
                caster_transform.translation,
                ability_damage,
                ability_healing,
                ability,
                target_entity,
            ));
            
            // Remove casting state
            // Note: GCD was already triggered when the cast began, not here
            commands.entity(caster_entity).remove::<CastingState>();
        }
    }
    
    // Track damage_dealt updates for casters (to apply after processing all casts)
    let mut caster_damage_updates: Vec<(Entity, f32)> = Vec::new();
    // Track healing_done updates for healers (to apply after processing all casts)
    let mut caster_healing_updates: Vec<(Entity, f32)> = Vec::new();
    // Track casters who should have stealth broken (offensive abilities)
    let mut break_stealth: Vec<Entity> = Vec::new();
    
    // Process completed casts
    for (caster_entity, caster_team, caster_class, caster_pos, ability_damage, ability_healing, ability, target_entity) in completed_casts {
        let def = ability.definition();
        
        // Get target
        let Some(target_entity) = target_entity else {
            continue;
        };
        
        // If this ability uses a projectile, spawn it and skip immediate effect application
        if let Some(projectile_speed) = def.projectile_speed {
            // Spawn projectile visual and logic entity
            commands.spawn((
                Projectile {
                    caster: caster_entity,
                    target: target_entity,
                    ability,
                    speed: projectile_speed,
                    caster_team,
                    caster_class,
                },
                PlayMatchEntity,
            ));
            continue; // Skip immediate damage/healing - projectile will handle it on impact
        }
        
        // Check if this is self-targeting (e.g., priest healing themselves)
        let is_self_target = target_entity == caster_entity;
        
        // Get target combatant
        let Ok((_, target_transform, mut target, _, target_auras)) = combatants.get_mut(target_entity) else {
            continue;
        };
        
        if !target.is_alive() {
            continue;
        }
        
        let target_pos = target_transform.translation;
        let distance = caster_pos.distance(target_pos);
        let text_position = target_transform.translation + Vec3::new(0.0, 2.0, 0.0);
        
        // Handle damage spells
        if def.is_damage() {
            // Use pre-calculated damage (already includes stat scaling)
            let damage = ability_damage;
            
            let actual_damage = damage.min(target.current_health);
            target.current_health = (target.current_health - damage).max(0.0);
            target.damage_taken += actual_damage;
            
            // Warriors generate Rage from taking damage
            if target.resource_type == ResourceType::Rage {
                let rage_gain = actual_damage * 0.15; // Gain 15% of damage taken as Rage
                target.current_mana = (target.current_mana + rage_gain).min(target.max_mana);
            }
            
            // Track damage for aura breaking
            commands.entity(target_entity).insert(DamageTakenThisFrame {
                amount: actual_damage,
            });
            
            // Break stealth on offensive ability use
            break_stealth.push(caster_entity);
            
            // Track damage dealt for caster (update later to avoid double borrow)
            if is_self_target {
                // Self-damage: target IS caster, so update now
                target.damage_dealt += actual_damage;
            } else {
                // Different target: collect for later update
                caster_damage_updates.push((caster_entity, actual_damage));
            }
            
            // Spawn floating combat text (yellow for damage abilities)
            // Get deterministic offset based on pattern state
            let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                get_next_fct_offset(&mut fct_state)
            } else {
                (0.0, 0.0)
            };
            commands.spawn((
                FloatingCombatText {
                    world_position: text_position + Vec3::new(offset_x, offset_y, 0.0),
                    text: format!("{:.0}", actual_damage),
                    color: egui::Color32::from_rgb(255, 255, 0), // Yellow for abilities
                    lifetime: 1.5,
                    vertical_offset: offset_y,
                },
                PlayMatchEntity,
            ));
            
            // Spawn visual effect for Mind Blast (shadow impact)
            if ability == AbilityType::MindBlast {
                commands.spawn((
                    SpellImpactEffect {
                        position: target_pos,
                        lifetime: 0.5,
                        initial_lifetime: 0.5,
                        initial_scale: 0.5,
                        final_scale: 2.0,
                    },
                    PlayMatchEntity,
                ));
            }
            
            // Log the damage
            let message = format!(
                "Team {} {}'s {} hits Team {} {} for {:.0} damage",
                caster_team,
                caster_class.name(),
                def.name,
                target.team,
                target.class.name(),
                actual_damage
            );
            combat_log.log_with_position(
                CombatLogEventType::Damage,
                message,
                PositionData {
                    entities: vec![
                        format!("Team {} {} (caster)", caster_team, caster_class.name()),
                        format!("Team {} {} (target)", target.team, target.class.name()),
                    ],
                    positions: vec![
                        (caster_pos.x, caster_pos.y, caster_pos.z),
                        (target_pos.x, target_pos.y, target_pos.z),
                    ],
                    distance: Some(distance),
                },
            );
        }
        // Handle healing spells
        else if def.is_heal() {
            // Use pre-calculated healing (already includes stat scaling)
            let mut healing = ability_healing;
            
            // Check for healing reduction auras
            if let Some(auras) = target_auras {
                for aura in &auras.auras {
                    if aura.effect_type == AuraType::HealingReduction {
                        // Magnitude is a multiplier (e.g., 0.65 = 35% reduction)
                        healing *= aura.magnitude;
                    }
                }
            }
            
            // Apply healing (don't overheal)
            let actual_healing = healing.min(target.max_health - target.current_health);
            target.current_health = (target.current_health + healing).min(target.max_health);
            
            // Track healing done for healer (update later to avoid double borrow)
            if is_self_target {
                // Self-healing: target IS caster, so update now
                target.healing_done += actual_healing;
            } else {
                // Different target: collect for later update
                caster_healing_updates.push((caster_entity, actual_healing));
            }
            
            // Spawn floating combat text (green for healing)
            // Get deterministic offset based on pattern state
            let (offset_x, offset_y) = if let Ok(mut fct_state) = fct_states.get_mut(target_entity) {
                get_next_fct_offset(&mut fct_state)
            } else {
                (0.0, 0.0)
            };
            commands.spawn((
                FloatingCombatText {
                    world_position: text_position + Vec3::new(offset_x, offset_y, 0.0),
                    text: format!("+{:.0}", actual_healing),
                    color: egui::Color32::from_rgb(100, 255, 100), // Green for healing
                    lifetime: 1.5,
                    vertical_offset: offset_y,
                },
                PlayMatchEntity,
            ));
            
            // Log the healing
            let message = format!(
                "Team {} {}'s {} heals Team {} {} for {:.0}",
                caster_team,
                caster_class.name(),
                def.name,
                target.team,
                target.class.name(),
                actual_healing
            );
            combat_log.log_with_position(
                CombatLogEventType::Healing,
                message,
                PositionData {
                    entities: vec![
                        format!("Team {} {} (caster)", caster_team, caster_class.name()),
                        format!("Team {} {} (target)", target.team, target.class.name()),
                    ],
                    positions: vec![
                        (caster_pos.x, caster_pos.y, caster_pos.z),
                        (target_pos.x, target_pos.y, target_pos.z),
                    ],
                    distance: Some(distance),
                },
            );
        }
        
        // Apply aura if applicable (store for later application)
        if let Some((aura_type, duration, magnitude, break_threshold)) = def.applies_aura {
            // We'll apply auras in a separate pass to avoid borrow issues
            commands.spawn((
                AuraPending {
                    target: target_entity,
                    aura: Aura {
                        effect_type: aura_type,
                        duration,
                        magnitude,
                        break_on_damage_threshold: break_threshold,
                        accumulated_damage: 0.0,
                        tick_interval: 0.0,
                        time_until_next_tick: 0.0,
                        caster: Some(caster_entity),
                    },
                },
                PlayMatchEntity,
            ));
            
            info!(
                "Queued {:?} aura for Team {} {} (magnitude: {}, duration: {}s)",
                aura_type,
                target.team,
                target.class.name(),
                magnitude,
                duration
            );
        }
        
        // Check for death
        if !target.is_alive() {
            let message = format!(
                "Team {} {} has been eliminated",
                target.team,
                target.class.name()
            );
            combat_log.log(CombatLogEventType::Death, message);
        }
    }
    
    // Apply collected caster damage updates
    for (caster_entity, damage) in caster_damage_updates {
        if let Ok((_, _, mut caster, _, _)) = combatants.get_mut(caster_entity) {
            caster.damage_dealt += damage;
        }
    }
    
    // Apply collected healer healing updates
    for (healer_entity, healing) in caster_healing_updates {
        if let Ok((_, _, mut healer, _, _)) = combatants.get_mut(healer_entity) {
            healer.healing_done += healing;
        }
    }
    
    // Break stealth for casters who used offensive abilities
    for caster_entity in break_stealth {
        if let Ok((_, _, mut caster, _, _)) = combatants.get_mut(caster_entity) {
            if caster.stealthed {
                caster.stealthed = false;
                info!(
                    "Team {} {} breaks stealth!",
                    caster.team,
                    caster.class.name()
                );
            }
        }
    }
}

